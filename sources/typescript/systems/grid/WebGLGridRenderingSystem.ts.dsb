import { Matrix4f, Vector2f } from '@cedric-demongivert/gl-tool-math'
import { Entity } from '@cedric-demongivert/gl-tool-ecs'
import { Component } from '@cedric-demongivert/gl-tool-ecs'
import { Program } from '@cedric-demongivert/gl-tool-shader'
import { WebGLUniforms } from '@cedric-demongivert/gl-tool-shader'
import { WebGLAttributes } from '@cedric-demongivert/gl-tool-shader'
import { FaceBuffer } from '@cedric-demongivert/gl-tool-buffer'
import { VertexStructureBuffer } from '@cedric-demongivert/gl-tool-buffer'

import { OverseerSystem } from '../OverseerSystem'
import { UnitManagementSystem } from '../UnitManagementSystem'
import { CameraManagementSystem } from '../CameraManagementSystem'

import { SquareGrid } from '../../components/SquareGrid'
import { Viewport } from '../../components/Viewport'
import { Camera } from '../../components/Camera'
import { Unit } from '../../components/Unit'

import { SquareGridType } from '../../types/SquareGridType'

import { GridGeometry } from './GridGeometry'
import { GridProgram } from './GridProgram'
import { GridVertexFormat } from './GridVertexFormat'

export class WebGLGridRenderingSystem extends OverseerSystem {
  public cameras : CameraManagementSystem
  public units : UnitManagementSystem

  private readonly _viewToGrid : Matrix4f
  private readonly _offset : Vector2f
  private readonly _dimension : Vector2f
  private readonly _unit : Vector2f

  /**
  * Create a new system that render meshes.
  */
  public constructor () {
    super()
    this.units = null
    this.cameras = null
    this._viewToGrid = new Matrix4f()
    this._offset = new Vector2f()
    this._dimension = new Vector2f()
    this._unit = new Vector2f()
  }

  public get isGLToolRenderable () {
    return true
  }

  /**
  * @see gltool-ecs/System#initialize
  */
  public initialize () : void {
    this.units = this.manager.requireSystem(UnitManagementSystem) as UnitManagementSystem
    this.cameras = this.manager.requireSystem(CameraManagementSystem) as CameraManagementSystem
  }

  /**
  * @see gltool-ecs/System#destroy
  */
  public destroy () : void {
    this.units = null
    this.cameras = null
  }

  /**
  * Make a render pass for the given viewport.
  *
  * @param context - A rendering context to use.
  * @param viewport - The viewport to render.
  * @param entity - An entity to render as a grid.
  */
  public render (context : WebGLRenderingContext, viewport : Viewport, entity : Entity) {
    if (this.manager.hasComponent(entity, SquareGridType)) {
      this.renderGrid(context, viewport, entity)
    }
  }

  /**
  * Transform the world bottom-left and top-right boundaries into grid
  * bottom-left and top-rightgrid boundaries.
  *
  * @param entity - Grid configuration to use.
  */
  public computeGridBoundaries (camera : Component<Camera>, entity : Entity) {
    const viewUnit : Unit = this.units.getUnit(camera.entity)
    const gridUnit : Unit = this.units.getUnit(entity)

    this._viewToGrid.copy(camera.data.viewToWorld)
    gridUnit.applyToMatrix(viewUnit, this._viewToGrid)
  }

  public initializeProgramUniform (viewport : Viewport, entity : Entity) : void {
    /*const grid : SquareGrid = this.manager.getComponent(entity, SquareGridType).data
    const glUniforms : GLUniforms = glProgram.uniforms

    glUniforms.setIfExists('viewToGrid', false, this._viewToGrid.buffer)
    glUniforms.setIfExists('unit', grid.unit.buffer)
    glUniforms.setIfExists('color', grid.color.buffer)
    glUniforms.setIfExists('thickness', grid.thickness)
    glUniforms.setIfExists('resolution', viewport.width, viewport.height)*/
  }

  public uploadVertices () : void {
    /*const glAttributes : GLAttributes = glProgram.attributes
    const glVertices : GLVertexStructureBuffer = glProgram.context.contextualisation(GridGeometry.VERTICES) as any as GLVertexStructureBuffer

    if (!glVertices.synchronized) {
      glVertices.synchronize()
    }

    glVertices.upload(GridVertexFormat.fields[0], glAttributes.attributes.get('position').location)*/
  }

  /**
  * Make a render pass for a given grid.
  *
  * @param context - A rendering context to use.
  * @param viewport - The viewport to render.
  * @param entity - The entity to render.
  */
  public renderGrid (context : WebGLRenderingContext, viewport : Viewport, entity : Entity) : void {
    /*console.log('rendering grid')
    const gl : WebGLRenderingContext = context.context
    const glProgram : GLProgram = this.contextualiseProgram(context, GridProgram.INSTANCE)
    const glFaces : GLFaceBuffer = context.contextualisation(GridGeometry.FACES) as any  as GLFaceBuffer

    glProgram.use()

    this.computeGridBoundaries(viewport.camera, entity)
    this.initializeProgramUniform(glProgram, viewport, entity)
    this.uploadVertices(glProgram)

    if (!glFaces.synchronized) {
      glFaces.synchronize()
    }

    glFaces.bind()

    gl.drawElements(gl.TRIANGLES, glFaces.descriptor.size * 3, gl.UNSIGNED_SHORT, 0)*/
  }
}
